TEMPLATE : 
- C'est ma colonne de droite du catalogue comprenant la section de recherche et la section des résultats. 

- Section RECHERCHE : 
    - Je n'ai pas mis de bouton pour le formulaire de recherche. J'ai paramétré la touche 'entrée' comme touche d'envoi (@keyup.enter) qui lance ma méthode associée à la recherche 'setSearch'. 
    - Les filtres sont précédés de 'form-check-input' qui ont des background-images stylés dans le scss.

- Section RESULTATS : 
    - On affiche les données dans les {{}} ou on crée des boucles en utilisant la notation pointée directement à partir des données du store plutôt que des computed. 
    - Pour les listes, on les affiche à l'horizontal en séparant les valeurs par un '/' sauf pour le dernier élément en utilisant un span avec v-if qui fonctionne avec tous les éléments du tableau sauf le dernier. 
    - On utilise des sections avec collapse. 



LOGIQUE SCRIPT : 

1.// Récupération des données des villes et des catégories pour les afficher comme filtres dans la recherche : Ca a déjà été fait dans le composant parent 'CataloguePage'. Donc maitenant, on va les chercher directement dans le store. 

2.// Paramétrage des recherches : 
    - Je fais mes recherches dans la store.state.formations que je récupère au lancement de la page du catalogue. Comme ca je ne fais qu'une requête initiale. 
    - Avec v-model, je récupère la valeur de l'input de recherche que je stocke dans la data 'searchWords' 
    - Je vais supprimer les espaces avant et arrière puis convertir en lowerCase la valeur de 'searchWords' et je supprime les accents grace à une regex. Puis je transforme ma string en tableau car je vais regarder si chaque élément (mot) de mon tableau est inclus dans le titre, le contenu ou le code de chaque formation du store. Je stocke le tout dans ma data 'searchWordsOptim'.
    - Pour récupérer depuis $store.state.formations un nouveau tableau "resultSearch" (en utilisant '.filter) avec le résultats de mes recherches, je crée la fonction "setSearch": 
        // Elle est la somme de toutes les recherches. 

        RECHERCHE PAR MOTS :
        // Je supprime les espaces avant et arrière puis je convertis en lowerCase les valeurs des attributs (titre, presentationRapide et code)  de mes items de $store.state.formations (en utilisant .toLowerCase), et je supprime les accents grace à une regex, comme ça les données venant du store sont en lowerCase et les valeurs des inputs sont en lowerCase donc plus de problème de ce cotè là ! "searchWordsOptim"
        // Je créé mon tableau qui contiendra les résultats du "filter" de ma liste globale des formations (store.state.formations). Je le créée comme data comme ça je bénéficie d'un scope général car je dois le réutiliser dans la suite de ma requête. "this.resultWords"
        // Je transforme le titre, le contenu et le code de la formation , avec 'trim' j'enleve les espaces avant et après, avec toLowerCase je mets tout en minuscule, avec normalize je décompose les lettres et diacritics, avec replace je supprime toutes les diacritics (signe accompagnant une lettre ou un graphème pour en modifier le sens ou la prononciation).
        // Ensuite je vais utiliser la fonction '.match' qui permet de regarder si une string (mon titre) comporte des éléments d'un tableau (ma data de recherche 'searchWordsOptim'). Je vais donc itérer mon tableau de recherche ('searchWordsOptim') et pour chaque élément du tableau je regarde si ma string (titre ou content ou code) le contient. Si oui, alors je retourne la valeur 'true', ce qui va conditionner l'ajout ou non de ma formation dans le tableau final des résultats. Ce tableau final est une variable de mon composant : 'resultSearch'. L'avantage, c'est que du coup je peux fournir une recherche avec plusieurs mots et que je peux proposer également des formations qui contiennent un match, deux matchs, etc. Comme ça si aucune ne comporte les 2 mots recherchés, je peux quand même en proposer qui en comportent un. Il me reste ensuite à trouver une astuce pour inscrire le nombre de matchs dans une propriété de la formation pour pouvoir afficher en priorité celles qui ont le plus de match. 
        Ce qui est bien c'est que si je n'ai rien entré dans ma recherche par mot, la fonction filter renvoie un tableau comprenant toutes les formations ! Donc c'est plus facile pour l'enchainement ! 
        // Pour finir, je transfère la valeur de mon résultat de recherche à la data "finalResult" que je vais pouvoir afficher dans mon html. Si la requête se poursuit avec des filtres, ma data finalResult pourra recevoir le résultat total de ma recherche (mots +  filtres). Car pour poursuivre ma recherche je vais reprendre ma var

        + FILTRES  : 
        // Ici, je dois trouver un stratagème pour pousser les unes à la suite des autres des conditions de matching pour une fonction finale de filter qui ressemblerait à ça : /* this.finalResult = this.resultWords.filter(function(item) { if( */  /* { item.attributes.CPF === true && item.attributes.qualifiante === true && item.attributes.distance === true  */  /* ) {return true} }); */ je vais donc décomposer ma fonction : une string de début (startOfRequest) : 'this.finalResult = this.resultWords.filter(function(item) { if( + un tableau "restOfRequest" dans lequel je vais pousser chacune des conditions qui auront été validées par un chechkbox.checked (par exemmple : item.attributes.CPF === true) + une string fin de fonction ("endOfRequest") : ) {return true} }); . Ensuite, je vais transformer mon tableau en string en lui ajoutant '&&' à chaque jointure (avec join()). Une fois que je n'ai que des string, je les concatène pour obtenir ma fonction finale (en string). Pour transformer cette string en code javascript et la lancer, je vais donc utiliser la méthode eval(). 
        // Une fois la fonction lancée, elle me retourne mont tableau de résultat final de ma requête (Mots + filtres) : this.finalResult, qui s'affiche dans le html. 
        // Je vérifie si des filtres dont activés pour insérer une instruction dans ma fonction finale : 
            - Pour les check-form : document.getElementById('form-check-cpf').checked === true
            - Pour les select avec options : j'implémente un v-model pour le select et j'utilise sa valeur pour poser ma condition. 
        // Pour vérifier la condition qu'un ville = Metz ou Nancy, j'utilise la méthode 'some' pour itérer le tableau sur une seul ligne ! 



3.// Création d'une page dynamique pour afficher le programme d'une formation spécifique choisie dans la liste des résultats : l'url de la page de la formation à afficher sera construite avec un paramètre d'url qui s'appelle "code" (il existe une route dans le router : "path: '/programme/:code') " et qui sera transmis via notre méthode 'showProgram' lors du click sur le bouton 'programme' de la formation concernée dans la liste des résultats. 

4.// Persistance des résultats de la recherche : si l'utilisateur souhaite aller voir une page programme de formation ou se connecter pour s'inscrire à une formation, je fais persister les données de la recherche de formations, pour qu'avec un retour du navigateur, il puisse retomber sur sa recherche effectuée précédemment. Pour faire cela, j'enregistre le [finalResult] de la recherche dans le localStorage et je dis que si il existe un item "recherche" dans le localStorage, alors le [finalResult] à afficher est celui du localStorage. Mais si l'utilisateur retourne sur la page d'accueil (ou d'autres page/views), alors au hook 'mounted' de ces pages, je supprime l'item "recherche" du localStorage. 
Je fais également persister les données de recherche (mots clés et filtres) en enregistrant les valeurs des paramètres de recherche (inputs, form-check, select) grace à v-model dans un objet "searchDatas" du store, car ce dernier n'est pas altéré par le re-render d'un composant. 

5.// Réinitialisation de la recherche : je créé un bouton associé à une fonction de réinitialisation. Attention à supprimer l'item 'recherche' du localstorage et à remettre FinalResult = []. Je réinitialise àgalement les valaurs des propriétés de l'obt 'searchDatas' du store. 

SCSS : 